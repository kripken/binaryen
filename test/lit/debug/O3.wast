;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt -O3 -all -S -o - | filecheck %s

;; The constant in the block here must still have a debug annotation after
;; we run the optimizer pipeline.
(module
  ;; CHECK:      (type $0 (func (result i32)))
  (type $0 (func (result i32)))
  ;; CHECK:      (export "bar" (func $bar))
  (export "bar" (func $bar))
  ;; CHECK:      (func $bar (type $0) (; has Stack IR ;) (result i32)
  ;; CHECK-NEXT:  ;;@ file.cpp:80:4
  ;; CHECK-NEXT:  (i32.const 42)
  ;; CHECK-NEXT: )
  (func $bar (result i32)
    (block $__inlined_func$foo (result i32)
      ;;@ file.cpp:80:4
      (i32.const 42)
    )
  )
)

;; As above, but test starting from an earlier point, before inlining.
(module
  (func $foo (result i32)
    ;;@ file.cpp:80:4
    (return
      (i32.const 42)
    )
  )

  ;; CHECK:      (type $0 (func (result i32)))

  ;; CHECK:      (export "bar" (func $bar))

  ;; CHECK:      (func $bar (type $0) (; has Stack IR ;) (result i32)
  ;; CHECK-NEXT:  ;;@ file.cpp:80:4
  ;; CHECK-NEXT:  (i32.const 42)
  ;; CHECK-NEXT: )
  (func $bar (export "bar") (result i32)
    (return
      (call $foo)
    )
  )
)

;; Add debug info on the other return as well. The final function has to pick
;; one of the two, and should keep the one it had before.
(module
  (func $foo (result i32)
    ;;@ file.cpp:80:4
    (return
      (i32.const 42)
    )
  )

  ;; CHECK:      (type $0 (func (result i32)))

  ;; CHECK:      (export "bar" (func $bar))

  ;; CHECK:      (func $bar (type $0) (; has Stack IR ;) (result i32)
  ;; CHECK-NEXT:  ;;@ file.cpp:1337:55
  ;; CHECK-NEXT:  (i32.const 42)
  ;; CHECK-NEXT: )
  (func $bar (export "bar") (result i32)
    ;; The inlined code's location should win over the area it is inlined into,
    ;; so the result should be 80:4 here.
    ;;@ file.cpp:1337:55
    (return
      (call $foo)
    )
  )
)

;; Test inlining of GC code and not a simple constant like before
(module
  ;; CHECK:      (type $struct (struct (field i32)))
  (type $struct (struct (field i32)))

  (func $create (result (ref $struct))
    ;;@ file.cpp:80:4
    (struct.new $struct
      (i32.const 42)
    )
  )

  ;; CHECK:      (type $1 (func (result (ref $struct))))

  ;; CHECK:      (export "bar" (func $bar))

  ;; CHECK:      (func $bar (type $1) (; has Stack IR ;) (result (ref $struct))
  ;; CHECK-NEXT:  ;;@ file.cpp:1337:55
  ;; CHECK-NEXT:  (struct.new $struct
  ;; CHECK-NEXT:   ;;@ file.cpp:80:4
  ;; CHECK-NEXT:   (i32.const 42)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  ;;@ file.cpp:1337:55
  ;; CHECK-NEXT: )
  (func $bar (export "bar") (result (ref $struct))
    ;; The inlined code's location should win over the area it is inlined into,
    ;; so the result should be 80:4 here.
    ;;@ file.cpp:1337:55
    (return
      (call $create)
    )
  )
)
