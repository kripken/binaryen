;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: foreach %s %t wasm-opt -all --inlining-optimizing -S -o - | filecheck %s

(module
 ;; CHECK:      (type $none_=>_none (func))
 (type $none_=>_none (func))
 (type $none_=>_i32 (func (result i32)))
 ;; CHECK:      (func $0 (type $none_=>_none)
 ;; CHECK-NEXT:  (nop)
 ;; CHECK-NEXT: )
 (func $0
  (nop)
 )
 ;; CHECK:      (func $1 (type $none_=>_none)
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (block ;; (replaces unreachable CallRef we can't emit)
 ;; CHECK-NEXT:    (drop
 ;; CHECK-NEXT:     (unreachable)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:    (unreachable)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $1
  ;; $0 will be inlined into here. We will then optimize this function - but
  ;; we do so *without* optimizing $0 (as inlining-optimizing only optimizes
  ;; where it inlines, for efficiency). As part of the optimiziations, we will
  ;; try to precompute the cast here, which will try to look up $0. We should
  ;; not hit an assertion, rather we should skip precomputing it, the same as if
  ;; we were optimizing $1 before $0 were added to the module. (In fact, we will
  ;; be able to see that the cast cannot succeed, and will optimize it into an
  ;; unreachable.)
  (call $0)
  (drop
   (call_ref $none_=>_i32
    (ref.cast (ref $none_=>_i32)
     (ref.func $0)
    )
   )
  )
 )
)

;; $2 cannot be inlined initially as it has two references, but after one cycle
;; it has only a single ref, after which we can inline it as a single-use
;; function. This requires us to recompute inlineability fully in each
;; iteration, updating after the latest changes.
(module
 ;; CHECK:      (type $0 (func (param f32)))

 ;; CHECK:      (type $1 (func))
 (type $1 (func))
 (type $0 (func (param f32)))
 ;; CHECK:      (func $0 (type $0) (param $0 f32)
 ;; CHECK-NEXT:  (nop)
 ;; CHECK-NEXT: )
 (func $0 (type $0) (param $0 f32)
  (call $2)
 )
 ;; CHECK:      (func $1 (type $1)
 ;; CHECK-NEXT:  (unreachable)
 ;; CHECK-NEXT: )
 (func $1 (type $1)
  (if
   (i32.const 1)
   (then
    (unreachable)
   )
  )
  (call $0_3)
 )
 (func $2 (type $1)
  (drop
   (block (result f32)
    (f32.const 0)
   )
  )
 )
 (func $0_3 (type $1)
  (call $2)
 )
)

;; $1, $2, $3 are all "trivial calls": functions that just call another
;; immediately. We inline such functions even though they have a call in them.
;; In this case multiple cycles are possible.
(module
 (type $0 (func (param i32 i32)))
 ;; CHECK:      (type $2 (func (param i32) (result i32)))

 ;; CHECK:      (type $1 (func (param i32 i32 i32)))
 (type $1 (func (param i32 i32 i32)))
 (type $2 (func (param i32) (result i32)))
 ;; CHECK:      (export "_ZNSt3__29allocatorIcE10deallocateEPcm" (func $3))
 (export "_ZNSt3__29allocatorIcE10deallocateEPcm" (func $3))
 ;; CHECK:      (func $0 (type $2) (param $0 i32) (result i32)
 ;; CHECK-NEXT:  (i32.const 0)
 ;; CHECK-NEXT: )
 (func $0 (param $0 i32) (result i32)
  (call $2
   (i32.const 0)
   (i32.const 0)
   (i32.const 0)
  )
  (i32.const 0)
 )
 (func $1 (param $0 i32) (param $1 i32)
  (call $4
   (i32.const 0)
   (i32.const 0)
  )
 )
 (func $2 (param $0 i32) (param $1 i32) (param $2 i32)
  (call $3
   (i32.const 0)
   (i32.const 0)
   (i32.const 0)
  )
 )
 ;; CHECK:      (func $3 (type $1) (param $0 i32) (param $1 i32) (param $2 i32)
 ;; CHECK-NEXT:  (nop)
 ;; CHECK-NEXT: )
 (func $3 (param $0 i32) (param $1 i32) (param $2 i32)
  (call $1
   (i32.const 0)
   (i32.const 0)
  )
 )
 (func $4 (param $0 i32) (param $1 i32)
  (nop)
 )
)

