;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt -all --gufa -S -o - | filecheck %s

;; Test optimizations for parallel type hierarchies (like objects and their
;; vtables

;;         $X             $X.vtable
;;        /   \            /     \
;;       $A   $B     $A.vtable  $B.vtable
(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $X.vtable (sub (struct )))
    (type $X.vtable (sub (struct)))

    ;; CHECK:       (type $A.vtable (sub $X.vtable (struct )))
    (type $A.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $B.vtable (sub $X.vtable (struct )))
    (type $B.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $X (sub (struct (field (ref $X.vtable)))))
    (type $X (sub (struct (field (ref $X.vtable)))))

    ;; CHECK:       (type $A (sub $X (struct (field (ref $A.vtable)))))
    (type $A (sub $X (struct (field (ref $A.vtable)))))

    ;; CHECK:       (type $B (sub $X (struct (field (ref $B.vtable)))))
    (type $B (sub $X (struct (field (ref $B.vtable)))))
  )

  ;; CHECK:      (type $6 (func))

  ;; CHECK:      (type $7 (func (result (ref null $X))))

  ;; CHECK:      (type $8 (func (result (ref $X))))

  ;; CHECK:      (import "a" "b" (func $import (type $7) (result (ref null $X))))
  (import "a" "b" (func $import (result (ref null $X))))

  ;; CHECK:      (import "a" "b" (func $import-nonnull (type $8) (result (ref $X))))
  (import "a" "b" (func $import-nonnull (result (ref $X))))

  ;; CHECK:      (global $X.vtable (ref $X.vtable) (struct.new_default $X.vtable))
  (global $X.vtable (ref $X.vtable) (struct.new $X.vtable))

  ;; CHECK:      (global $A.vtable (ref $A.vtable) (struct.new_default $A.vtable))
  (global $A.vtable (ref $A.vtable) (struct.new $A.vtable))

  ;; CHECK:      (global $B.vtable (ref $B.vtable) (struct.new_default $B.vtable))
  (global $B.vtable (ref $B.vtable) (struct.new $B.vtable))

  ;; CHECK:      (func $create (type $6)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $X
  ;; CHECK-NEXT:    (global.get $X.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (global.get $A.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (global.get $B.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create
    (drop
      (struct.new $X
        (global.get $X.vtable)
      )
    )
    (drop
      (struct.new $A
        (global.get $A.vtable)
      )
    )
    (drop
      (struct.new $B
        (global.get $B.vtable)
      )
    )
  )

  ;; CHECK:      (func $test (type $6)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A)
  ;; CHECK-NEXT:    (ref.as_non_null
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B)
  ;; CHECK-NEXT:    (ref.as_non_null
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B)
  ;; CHECK-NEXT:    (call $import-nonnull)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $X 0
  ;; CHECK-NEXT:      (call $import)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; The import contains an unknown value. Testing if it is an object with
    ;; $A's vtable can be replaced by testing if it is $A, directly.
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    ;; Ditto, with $B.
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    ;; Ditto, with a non-nullable result from the import. That lets us skip
    ;; adding a cast to non-null ourselves (which normally we need, as the
    ;; struct.get that we remove would trap on null).
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $X 0
          (call $import-nonnull)
        )
      )
    )
    ;; For completion, tests of the other types, which are unoptimizable using
    ;; parallel type hierarchies (but the first is, separately, optimizable to
    ;; zero since the test is of an incompatible type).
    (drop
      (ref.test (ref $X)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    (drop
      (ref.test (ref $A)
        (call $import)
      )
    )
    (drop
      (ref.test (ref $B)
        (call $import)
      )
    )
  )
)

;; As above, but now $X is an abstract type - we never create it. We can still
;; optimize.
(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $X.vtable (sub (struct )))
    (type $X.vtable (sub (struct)))

    ;; CHECK:       (type $A.vtable (sub $X.vtable (struct )))
    (type $A.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $B.vtable (sub $X.vtable (struct )))
    (type $B.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $X (sub (struct (field (ref $X.vtable)))))
    (type $X (sub (struct (field (ref $X.vtable)))))

    ;; CHECK:       (type $A (sub $X (struct (field (ref $A.vtable)))))
    (type $A (sub $X (struct (field (ref $A.vtable)))))

    ;; CHECK:       (type $B (sub $X (struct (field (ref $B.vtable)))))
    (type $B (sub $X (struct (field (ref $B.vtable)))))
  )

  ;; CHECK:      (type $6 (func))

  ;; CHECK:      (type $7 (func (result (ref $X))))

  ;; CHECK:      (import "a" "b" (func $import (type $7) (result (ref $X))))
  (import "a" "b" (func $import (result (ref $X))))

  ;; CHECK:      (global $X.vtable (ref $X.vtable) (struct.new_default $X.vtable))
  (global $X.vtable (ref $X.vtable) (struct.new $X.vtable))

  ;; CHECK:      (global $A.vtable (ref $A.vtable) (struct.new_default $A.vtable))
  (global $A.vtable (ref $A.vtable) (struct.new $A.vtable))

  ;; CHECK:      (global $B.vtable (ref $B.vtable) (struct.new_default $B.vtable))
  (global $B.vtable (ref $B.vtable) (struct.new $B.vtable))

  ;; CHECK:      (func $create (type $6)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (global.get $A.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (global.get $B.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create
    ;; The struct.new of $X was removed here.
    (drop
      (struct.new $A
        (global.get $A.vtable)
      )
    )
    (drop
      (struct.new $B
        (global.get $B.vtable)
      )
    )
  )

  ;; CHECK:      (func $test (type $6)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; We can optimize here.
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
  )
)

;; As above, but there is a "skip" in the hierarchy: a type in between $X and
;; $A, which is *not* reflected in the vtable:
;;
;;         $X             $X.vtable
;;        /   \            /     \
;;       $M   $B     $A.vtable  $B.vtable
;;        |
;;       $A
;;
;; The extra type $M in the middle is never created and so it does not pose a
;; problem.
(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $X.vtable (sub (struct )))
    (type $X.vtable (sub (struct)))

    ;; CHECK:       (type $A.vtable (sub $X.vtable (struct )))
    (type $A.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $B.vtable (sub $X.vtable (struct )))
    (type $B.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $X (sub (struct (field (ref $X.vtable)))))
    (type $X (sub (struct (field (ref $X.vtable)))))

    ;; CHECK:       (type $M (sub $X (struct (field (ref $X.vtable)))))
    (type $M (sub $X (struct (field (ref $X.vtable)))))

    ;; CHECK:       (type $B (sub $X (struct (field (ref $B.vtable)))))
    (type $B (sub $X (struct (field (ref $B.vtable)))))

    ;; CHECK:       (type $A (sub $M (struct (field (ref $A.vtable)))))
    (type $A (sub $M (struct (field (ref $A.vtable)))))
  )

  ;; CHECK:      (type $7 (func))

  ;; CHECK:      (type $8 (func (result (ref $X))))

  ;; CHECK:      (import "a" "b" (func $import (type $8) (result (ref $X))))
  (import "a" "b" (func $import (result (ref $X))))

  ;; CHECK:      (global $X.vtable (ref $X.vtable) (struct.new_default $X.vtable))
  (global $X.vtable (ref $X.vtable) (struct.new $X.vtable))

  ;; CHECK:      (global $A.vtable (ref $A.vtable) (struct.new_default $A.vtable))
  (global $A.vtable (ref $A.vtable) (struct.new $A.vtable))

  ;; CHECK:      (global $B.vtable (ref $B.vtable) (struct.new_default $B.vtable))
  (global $B.vtable (ref $B.vtable) (struct.new $B.vtable))

  ;; CHECK:      (func $create (type $7)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $X
  ;; CHECK-NEXT:    (global.get $X.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (global.get $A.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (global.get $B.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create
    (drop
      (struct.new $X
        (global.get $X.vtable)
      )
    )
    (drop
      (struct.new $A
        (global.get $A.vtable)
      )
    )
    (drop
      (struct.new $B
        (global.get $B.vtable)
      )
    )
  )

  ;; CHECK:      (func $test (type $7)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; We can optimize here.
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
  )
)

;; As the last testcase but now $M is instantiated.
(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $X.vtable (sub (struct )))
    (type $X.vtable (sub (struct)))

    ;; CHECK:       (type $A.vtable (sub $X.vtable (struct )))
    (type $A.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $B.vtable (sub $X.vtable (struct )))
    (type $B.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $X (sub (struct (field (ref $X.vtable)))))
    (type $X (sub (struct (field (ref $X.vtable)))))

    ;; CHECK:       (type $M (sub $X (struct (field (ref $X.vtable)))))
    (type $M (sub $X (struct (field (ref $X.vtable)))))

    ;; CHECK:       (type $B (sub $X (struct (field (ref $B.vtable)))))
    (type $B (sub $X (struct (field (ref $B.vtable)))))

    ;; CHECK:       (type $A (sub $M (struct (field (ref $A.vtable)))))
    (type $A (sub $M (struct (field (ref $A.vtable)))))
  )

  ;; CHECK:      (type $7 (func))

  ;; CHECK:      (type $8 (func (result (ref $X))))

  ;; CHECK:      (import "a" "b" (func $import (type $8) (result (ref $X))))
  (import "a" "b" (func $import (result (ref $X))))

  ;; CHECK:      (global $X.vtable (ref $X.vtable) (struct.new_default $X.vtable))
  (global $X.vtable (ref $X.vtable) (struct.new $X.vtable))

  ;; CHECK:      (global $A.vtable (ref $A.vtable) (struct.new_default $A.vtable))
  (global $A.vtable (ref $A.vtable) (struct.new $A.vtable))

  ;; CHECK:      (global $B.vtable (ref $B.vtable) (struct.new_default $B.vtable))
  (global $B.vtable (ref $B.vtable) (struct.new $B.vtable))

  ;; CHECK:      (func $create (type $7)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $X
  ;; CHECK-NEXT:    (global.get $X.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (global.get $A.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (global.get $B.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $M
  ;; CHECK-NEXT:    (global.get $X.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create
    (drop
      (struct.new $X
        (global.get $X.vtable)
      )
    )
    (drop
      (struct.new $A
        (global.get $A.vtable)
      )
    )
    (drop
      (struct.new $B
        (global.get $B.vtable)
      )
    )
    ;; This was added.
    (drop
      (struct.new $M
        (global.get $X.vtable)
      )
    )
  )

  ;; CHECK:      (func $test (type $7)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A.vtable)
  ;; CHECK-NEXT:    (struct.get $X 0
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B.vtable)
  ;; CHECK-NEXT:    (struct.get $X 0
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; We cannot optimize here, as $M uses $X's vtable, breaking the 1:1
    ;; relationship.
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
  )
)

;; As the testcase before last with a "skip" in the hierarchy, but now it is on
;; the vtable side:
;;
;;         $X             $X.vtable
;;        /   \            /     \
;;       $A   $B     $A.vtable  $M.vtable
;;                                |
;;                              $B.vtable
;;
;; Again, we can optimize here.
(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $X.vtable (sub (struct )))
    (type $X.vtable (sub (struct)))

    ;; CHECK:       (type $A.vtable (sub $X.vtable (struct )))
    (type $A.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $M.vtable (sub $X.vtable (struct )))
    (type $M.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $B.vtable (sub $M.vtable (struct )))
    (type $B.vtable (sub $M.vtable (struct)))

    ;; CHECK:       (type $X (sub (struct (field (ref $X.vtable)))))
    (type $X (sub (struct (field (ref $X.vtable)))))

    ;; CHECK:       (type $A (sub $X (struct (field (ref $A.vtable)))))
    (type $A (sub $X (struct (field (ref $A.vtable)))))

    ;; CHECK:       (type $B (sub $X (struct (field (ref $B.vtable)))))
    (type $B (sub $X (struct (field (ref $B.vtable)))))

  )

  ;; CHECK:      (type $7 (func))

  ;; CHECK:      (type $8 (func (result (ref $X))))

  ;; CHECK:      (import "a" "b" (func $import (type $8) (result (ref $X))))
  (import "a" "b" (func $import (result (ref $X))))

  ;; CHECK:      (global $X.vtable (ref $X.vtable) (struct.new_default $X.vtable))
  (global $X.vtable (ref $X.vtable) (struct.new $X.vtable))

  ;; CHECK:      (global $A.vtable (ref $A.vtable) (struct.new_default $A.vtable))
  (global $A.vtable (ref $A.vtable) (struct.new $A.vtable))

  ;; CHECK:      (global $B.vtable (ref $B.vtable) (struct.new_default $B.vtable))
  (global $B.vtable (ref $B.vtable) (struct.new $B.vtable))

  ;; CHECK:      (func $create (type $7)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $X
  ;; CHECK-NEXT:    (global.get $X.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (global.get $A.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (global.get $B.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create
    (drop
      (struct.new $X
        (global.get $X.vtable)
      )
    )
    (drop
      (struct.new $A
        (global.get $A.vtable)
      )
    )
    (drop
      (struct.new $B
        (global.get $B.vtable)
      )
    )
  )

  ;; CHECK:      (func $test (type $7)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $M.vtable)
  ;; CHECK-NEXT:    (struct.get $X 0
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; We can optimize here.
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    ;; We definitely cannot optimize a test of $M.vtable, as there is no $M at
    ;; all to test against.
    (drop
      (ref.test (ref $M.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
  )
)

;; As the last testcase but now $M.vtable is instantiated.
(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $X.vtable (sub (struct )))
    (type $X.vtable (sub (struct)))

    ;; CHECK:       (type $A.vtable (sub $X.vtable (struct )))
    (type $A.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $M.vtable (sub $X.vtable (struct )))
    (type $M.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $B.vtable (sub $M.vtable (struct )))
    (type $B.vtable (sub $M.vtable (struct)))

    ;; CHECK:       (type $X (sub (struct (field (ref $X.vtable)))))
    (type $X (sub (struct (field (ref $X.vtable)))))

    ;; CHECK:       (type $A (sub $X (struct (field (ref $A.vtable)))))
    (type $A (sub $X (struct (field (ref $A.vtable)))))

    ;; CHECK:       (type $B (sub $X (struct (field (ref $B.vtable)))))
    (type $B (sub $X (struct (field (ref $B.vtable)))))

  )

  ;; CHECK:      (type $7 (func))

  ;; CHECK:      (type $8 (func (result (ref $X))))

  ;; CHECK:      (import "a" "b" (func $import (type $8) (result (ref $X))))
  (import "a" "b" (func $import (result (ref $X))))

  ;; CHECK:      (global $X.vtable (ref $X.vtable) (struct.new_default $X.vtable))
  (global $X.vtable (ref $X.vtable) (struct.new $X.vtable))

  ;; CHECK:      (global $A.vtable (ref $A.vtable) (struct.new_default $A.vtable))
  (global $A.vtable (ref $A.vtable) (struct.new $A.vtable))

  ;; CHECK:      (global $B.vtable (ref $B.vtable) (struct.new_default $B.vtable))
  (global $B.vtable (ref $B.vtable) (struct.new $B.vtable))

  ;; CHECK:      (global $M.vtable (ref $X.vtable) (struct.new_default $X.vtable))
  (global $M.vtable (ref $X.vtable) (struct.new $X.vtable))

  ;; CHECK:      (func $create (type $7)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $X
  ;; CHECK-NEXT:    (global.get $X.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (global.get $A.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (global.get $B.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create
    (drop
      (struct.new $X
        (global.get $X.vtable)
      )
    )
    (drop
      (struct.new $A
        (global.get $A.vtable)
      )
    )
    (drop
      (struct.new $B
        (global.get $B.vtable)
      )
    )
  )

  ;; CHECK:      (func $test (type $7)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $M.vtable)
  ;; CHECK-NEXT:    (struct.get $X 0
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; We can optimize here: $M.vtable is instantiated, but there is no $M, so
    ;; does not interfere.
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    ;; We still cannot optimize a test of $M.vtable, as there is no $M at
    ;; all to test against.
    (drop
      (ref.test (ref $M.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
  )
)

;; As the last testcase but now $M and $M.vtable exist:
;;
;;
;;         $X             $X.vtable
;;        /   \            /     \
;;       $M   $B     $A.vtable  $M.vtable
;;        |                       |
;;       $A                     $B.vtable
;;
(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $X.vtable (sub (struct )))
    (type $X.vtable (sub (struct)))

    ;; CHECK:       (type $A.vtable (sub $X.vtable (struct )))
    (type $A.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $M.vtable (sub $X.vtable (struct )))
    (type $M.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $B.vtable (sub $M.vtable (struct )))
    (type $B.vtable (sub $M.vtable (struct)))

    ;; CHECK:       (type $X (sub (struct (field (ref $X.vtable)))))
    (type $X (sub (struct (field (ref $X.vtable)))))

    ;; CHECK:       (type $M (sub $X (struct (field (ref $X.vtable)))))
    (type $M (sub $X (struct (field (ref $X.vtable)))))

    ;; CHECK:       (type $B (sub $X (struct (field (ref $B.vtable)))))
    (type $B (sub $X (struct (field (ref $B.vtable)))))

    ;; CHECK:       (type $A (sub $M (struct (field (ref $A.vtable)))))
    (type $A (sub $M (struct (field (ref $A.vtable)))))
  )

  ;; CHECK:      (type $8 (func))

  ;; CHECK:      (type $9 (func (result (ref $X))))

  ;; CHECK:      (import "a" "b" (func $import (type $9) (result (ref $X))))
  (import "a" "b" (func $import (result (ref $X))))

  ;; CHECK:      (global $X.vtable (ref $X.vtable) (struct.new_default $X.vtable))
  (global $X.vtable (ref $X.vtable) (struct.new $X.vtable))

  ;; CHECK:      (global $A.vtable (ref $A.vtable) (struct.new_default $A.vtable))
  (global $A.vtable (ref $A.vtable) (struct.new $A.vtable))

  ;; CHECK:      (global $B.vtable (ref $B.vtable) (struct.new_default $B.vtable))
  (global $B.vtable (ref $B.vtable) (struct.new $B.vtable))

  ;; CHECK:      (global $M.vtable (ref $X.vtable) (struct.new_default $X.vtable))
  (global $M.vtable (ref $X.vtable) (struct.new $X.vtable))

  ;; CHECK:      (func $create (type $8)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $X
  ;; CHECK-NEXT:    (global.get $X.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (global.get $A.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (global.get $B.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $M
  ;; CHECK-NEXT:    (global.get $M.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create
    (drop
      (struct.new $X
        (global.get $X.vtable)
      )
    )
    (drop
      (struct.new $A
        (global.get $A.vtable)
      )
    )
    (drop
      (struct.new $B
        (global.get $B.vtable)
      )
    )
    (drop
      (struct.new $M
        (global.get $M.vtable)
      )
    )
  )

  ;; CHECK:      (func $test (type $8)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A.vtable)
  ;; CHECK-NEXT:    (struct.get $X 0
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B.vtable)
  ;; CHECK-NEXT:    (struct.get $X 0
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $M.vtable)
  ;; CHECK-NEXT:    (struct.get $X 0
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; We cannot optimize here: $M is the parent of $A while $M.vtable is the
    ;; parent of $B.vtable, so the object and vtable hierarchies are not
    ;; parallel.
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    (drop
      (ref.test (ref $M.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
  )
)

;; As above but move $M.table to the right place, as parent of $A.vtable.
(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $X.vtable (sub (struct )))
    (type $X.vtable (sub (struct)))

    ;; CHECK:       (type $M.vtable (sub $X.vtable (struct )))
    (type $M.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $A.vtable (sub $M.vtable (struct )))
    (type $A.vtable (sub $M.vtable (struct)))

    ;; CHECK:       (type $B.vtable (sub $X.vtable (struct )))
    (type $B.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $X (sub (struct (field (ref $X.vtable)))))
    (type $X (sub (struct (field (ref $X.vtable)))))

    ;; CHECK:       (type $M (sub $X (struct (field (ref $M.vtable)))))
    (type $M (sub $X (struct (field (ref $M.vtable)))))

    ;; CHECK:       (type $A (sub $M (struct (field (ref $A.vtable)))))
    (type $A (sub $M (struct (field (ref $A.vtable)))))

    ;; CHECK:       (type $B (sub $X (struct (field (ref $B.vtable)))))
    (type $B (sub $X (struct (field (ref $B.vtable)))))
  )

  ;; CHECK:      (type $8 (func))

  ;; CHECK:      (type $9 (func (result (ref $X))))

  ;; CHECK:      (type $10 (func (result (ref $M))))

  ;; CHECK:      (import "a" "b" (func $import-X (type $9) (result (ref $X))))
  (import "a" "b" (func $import-X (result (ref $X))))

  ;; CHECK:      (import "a" "c" (func $import-M (type $10) (result (ref $M))))
  (import "a" "c" (func $import-M (result (ref $M))))

  ;; CHECK:      (global $X.vtable (ref $X.vtable) (struct.new_default $X.vtable))
  (global $X.vtable (ref $X.vtable) (struct.new $X.vtable))

  ;; CHECK:      (global $A.vtable (ref $A.vtable) (struct.new_default $A.vtable))
  (global $A.vtable (ref $A.vtable) (struct.new $A.vtable))

  ;; CHECK:      (global $B.vtable (ref $B.vtable) (struct.new_default $B.vtable))
  (global $B.vtable (ref $B.vtable) (struct.new $B.vtable))

  ;; CHECK:      (global $M.vtable (ref $M.vtable) (struct.new_default $M.vtable))
  (global $M.vtable (ref $M.vtable) (struct.new $M.vtable))

  ;; CHECK:      (func $create (type $8)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $X
  ;; CHECK-NEXT:    (global.get $X.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (global.get $A.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (global.get $B.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $M
  ;; CHECK-NEXT:    (global.get $M.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create
    (drop
      (struct.new $X
        (global.get $X.vtable)
      )
    )
    (drop
      (struct.new $A
        (global.get $A.vtable)
      )
    )
    (drop
      (struct.new $B
        (global.get $B.vtable)
      )
    )
    (drop
      (struct.new $M
        (global.get $M.vtable)
      )
    )
  )

  ;; CHECK:      (func $test (type $8)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A)
  ;; CHECK-NEXT:    (call $import-X)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B)
  ;; CHECK-NEXT:    (call $import-X)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $M)
  ;; CHECK-NEXT:    (call $import-X)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A)
  ;; CHECK-NEXT:    (call $import-M)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $M 0
  ;; CHECK-NEXT:      (call $import-M)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $M 0
  ;; CHECK-NEXT:      (call $import-M)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; We can optimize here.
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $X 0
          (call $import-X)
        )
      )
    )
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $X 0
          (call $import-X)
        )
      )
    )
    (drop
      (ref.test (ref $M.vtable)
        (struct.get $X 0
          (call $import-X)
        )
      )
    )
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $M 0
          (call $import-M)
        )
      )
    )
    ;; These last two can be trivially optimized even without parallel type
    ;; hierarchy analysis.
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $M 0
          (call $import-M)
        )
      )
    )
    (drop
      (ref.test (ref $M.vtable)
        (struct.get $M 0
          (call $import-M)
        )
      )
    )
  )
)

;; As the first but now the vtable field is mutable (which also prevents vtable
;; subtyping). We do not optimize here.
(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $X.vtable (sub (struct )))
    (type $X.vtable (sub (struct)))

    ;; CHECK:       (type $X (sub (struct (field (mut (ref $X.vtable))))))
    (type $X (sub (struct (field (mut (ref $X.vtable))))))

    ;; CHECK:       (type $A (sub $X (struct (field (mut (ref $X.vtable))))))
    (type $A (sub $X (struct (field (mut (ref $X.vtable))))))

    ;; CHECK:       (type $B (sub $X (struct (field (mut (ref $X.vtable))))))
    (type $B (sub $X (struct (field (mut (ref $X.vtable))))))
  )

  ;; CHECK:      (type $4 (func))

  ;; CHECK:      (type $5 (func (result (ref null $X))))

  ;; CHECK:      (type $6 (func (result (ref $X))))

  ;; CHECK:      (import "a" "b" (func $import (type $5) (result (ref null $X))))
  (import "a" "b" (func $import (result (ref null $X))))

  ;; CHECK:      (import "a" "b" (func $import-nonnull (type $6) (result (ref $X))))
  (import "a" "b" (func $import-nonnull (result (ref $X))))

  ;; CHECK:      (global $X.vtable (ref $X.vtable) (struct.new_default $X.vtable))
  (global $X.vtable (ref $X.vtable) (struct.new $X.vtable))

  ;; CHECK:      (global $A.vtable (ref $X.vtable) (struct.new_default $X.vtable))
  (global $A.vtable (ref $X.vtable) (struct.new $X.vtable))

  ;; CHECK:      (global $B.vtable (ref $X.vtable) (struct.new_default $X.vtable))
  (global $B.vtable (ref $X.vtable) (struct.new $X.vtable))

  ;; CHECK:      (func $create (type $4)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $X
  ;; CHECK-NEXT:    (global.get $X.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (global.get $X.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (global.get $X.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create
    (drop
      (struct.new $X
        (global.get $X.vtable)
      )
    )
    (drop
      (struct.new $A
        (global.get $X.vtable)
      )
    )
    (drop
      (struct.new $B
        (global.get $X.vtable)
      )
    )
  )

  ;; CHECK:      (func $test (type $4)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block (result (ref $X.vtable))
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (struct.get $X 0
  ;; CHECK-NEXT:        (call $import)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (global.get $X.vtable)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; The vtable field is mutable so there is nothing interesting to optimize
    ;; here (however, the test can be inferred to always be 1, separately).
    (drop
      (ref.test (ref $X.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
  )
)

;; Three fields: one optimizable, one not, and one that isn't even a ref (so it
;; definitely is not optimizable).
;;
;; Specifically, the first field has $A.vtable in both subtypes (so there is no
;; 1:1 of object to vtable); the second has $B.vtable for $A and vice versa, so
;; it is "flipped" compared to the first testcase, but that is fine; the third
;; is an i32.
(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $X.vtable (sub (struct )))
    (type $X.vtable (sub (struct)))

    ;; CHECK:       (type $A.vtable (sub $X.vtable (struct )))
    (type $A.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $B.vtable (sub $X.vtable (struct )))
    (type $B.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $X (sub (struct (field (ref $X.vtable)) (field (ref $X.vtable)) (field i32))))
    (type $X (sub (struct (field (ref $X.vtable)) (field (ref $X.vtable)) (field i32))))

    ;; CHECK:       (type $A (sub $X (struct (field (ref $A.vtable)) (field (ref $B.vtable)) (field i32))))
    (type $A (sub $X (struct (field (ref $A.vtable)) (field (ref $B.vtable)) (field i32))))

    ;; CHECK:       (type $B (sub $X (struct (field (ref $A.vtable)) (field (ref $A.vtable)) (field i32))))
    (type $B (sub $X (struct (field (ref $A.vtable)) (field (ref $A.vtable)) (field i32))))
  )

  ;; CHECK:      (type $6 (func))

  ;; CHECK:      (type $7 (func (result (ref $X))))

  ;; CHECK:      (import "a" "b" (func $import (type $7) (result (ref $X))))
  (import "a" "b" (func $import (result (ref $X))))

  ;; CHECK:      (global $X.vtable (ref $X.vtable) (struct.new_default $X.vtable))
  (global $X.vtable (ref $X.vtable) (struct.new $X.vtable))

  ;; CHECK:      (global $A.vtable (ref $A.vtable) (struct.new_default $A.vtable))
  (global $A.vtable (ref $A.vtable) (struct.new $A.vtable))

  ;; CHECK:      (func $create (type $6)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $X
  ;; CHECK-NEXT:    (global.get $X.vtable)
  ;; CHECK-NEXT:    (global.get $X.vtable)
  ;; CHECK-NEXT:    (i32.const 0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (struct.new_default $A.vtable)
  ;; CHECK-NEXT:    (block (result (ref $B.vtable))
  ;; CHECK-NEXT:     (struct.new_default $B.vtable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (global.get $A.vtable)
  ;; CHECK-NEXT:    (global.get $A.vtable)
  ;; CHECK-NEXT:    (i32.const 2)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create
    (drop
      (struct.new $X
        (global.get $X.vtable)
        (global.get $X.vtable)
        (i32.const 0)
      )
    )
    (drop
      (struct.new $A
        ;; For more coverage, test using something other than global.gets here.
        (struct.new $A.vtable)
        (block (result (ref $B.vtable))
          (struct.new $B.vtable)
        )
        (i32.const 1)
      )
    )
    (drop
      (struct.new $B
        (global.get $A.vtable)
        (global.get $A.vtable)
        (i32.const 2)
      )
    )
  )

  ;; CHECK:      (func $test (type $6)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A.vtable)
  ;; CHECK-NEXT:    (struct.get $X 0
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B.vtable)
  ;; CHECK-NEXT:    (struct.get $X 0
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $X 2
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $X 2
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; We fail to optimize the first field.
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    ;; We succeed on the second. Note that we test $B for $A.vtable and vice
    ;; versa.
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $X 1
          (call $import)
        )
      )
    )
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $X 1
          (call $import)
        )
      )
    )
    ;; Nothing to even test on the third.
    (drop
      (struct.get $X 2
        (call $import)
      )
    )
    (drop
      (struct.get $X 2
        (call $import)
      )
    )
  )
)

;; Deeper hierarchies:
;;
;;         $X             $X.vtable
;;        /   \            /     \
;;       $A   $B     $A.vtable  $B.vtable
;;        |    |          |
;;       $C   $D     $C.vtable  (note $B.vtable has no subtype; $D uses $B's)
(module
  (rec
    ;; CHECK:      (type $0 (func))

    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $X.vtable (sub (struct )))
    (type $X.vtable (sub (struct)))

    ;; CHECK:       (type $A.vtable (sub $X.vtable (struct )))
    (type $A.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $B.vtable (sub $X.vtable (struct )))
    (type $B.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $C.vtable (sub $A.vtable (struct )))
    (type $C.vtable (sub $A.vtable (struct)))

    ;; CHECK:       (type $X (sub (struct (field (ref $X.vtable)))))
    (type $X (sub (struct (field (ref $X.vtable)))))

    ;; CHECK:       (type $A (sub $X (struct (field (ref $A.vtable)))))
    (type $A (sub $X (struct (field (ref $A.vtable)))))

    ;; CHECK:       (type $B (sub $X (struct (field (ref $B.vtable)))))
    (type $B (sub $X (struct (field (ref $B.vtable)))))

    ;; CHECK:       (type $C (sub $A (struct (field (ref $C.vtable)))))
    (type $C (sub $A (struct (field (ref $C.vtable)))))

    ;; CHECK:       (type $D (sub $B (struct (field (ref $B.vtable)))))
    (type $D (sub $B (struct (field (ref $B.vtable)))))
  )

  ;; CHECK:      (type $10 (func (result (ref $X))))

  ;; CHECK:      (type $11 (func (result (ref $A))))

  ;; CHECK:      (type $12 (func (result (ref $B))))

  ;; CHECK:      (import "a" "b" (func $import (type $10) (result (ref $X))))
  (import "a" "b" (func $import (result (ref $X))))

  ;; CHECK:      (import "a" "c" (func $import-A (type $11) (result (ref $A))))
  (import "a" "c" (func $import-A (result (ref $A))))

  ;; CHECK:      (import "a" "d" (func $import-B (type $12) (result (ref $B))))
  (import "a" "d" (func $import-B (result (ref $B))))

  ;; CHECK:      (func $create (type $0)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (struct.new_default $A.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (struct.new_default $B.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $C
  ;; CHECK-NEXT:    (struct.new_default $C.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $D
  ;; CHECK-NEXT:    (struct.new_default $B.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create
    (drop
      (struct.new $A
        (struct.new $A.vtable)
      )
    )
    (drop
      (struct.new $B
        (struct.new $B.vtable)
      )
    )
    (drop
      (struct.new $C
        (struct.new $C.vtable)
      )
    )
    (drop
      (struct.new $D
        (struct.new $B.vtable) ;; As mentioned before, $D uses a $B.vtable.
      )
    )
  )

  ;; CHECK:      (func $test.X (type $0)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A.vtable)
  ;; CHECK-NEXT:    (struct.get $X 0
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B.vtable)
  ;; CHECK-NEXT:    (struct.get $X 0
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $C.vtable)
  ;; CHECK-NEXT:    (struct.get $X 0
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test.X
    ;; Loads from $X. We do not optimize anything here because $D does not have
    ;; its own vtable, as mentioned before. We could in principle optimize in
    ;; certain cases even so TODO
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    (drop
      (ref.test (ref $C.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
  )

  ;; CHECK:      (func $test.A (type $0)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $A 0
  ;; CHECK-NEXT:      (call $import-A)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $C)
  ;; CHECK-NEXT:    (call $import-A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test.A
    ;; Loads from $A. The first must always succeed, while the second is an
    ;; interesting case to optimize as it shows we can optimize into a branch of
    ;; the subtype tree that is not polluted by $D using $B's vtable (indeed,
    ;; testing on $C.vtable is fine since it can only be $C's or $A's, and
    ;; nothing else - the pollution does not reach here).
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $A 0
          (call $import-A)
        )
      )
    )
    (drop
      (ref.test (ref $C.vtable)
        (struct.get $A 0
          (call $import-A)
        )
      )
    )
  )

  ;; CHECK:      (func $test.B (type $0)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $B 0
  ;; CHECK-NEXT:      (call $import-B)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $B 0
  ;; CHECK-NEXT:      (call $import-B)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test.B
    ;; Loads from $B. $B and $D use the same vtable so these are all trivially
    ;; 1 anyhow.
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $B 0
          (call $import-B)
        )
      )
    )
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $B 0
          (call $import-B)
        )
      )
    )
  )
)

;; As the last testcase, but "fix" $D by adding $D.vtable and using that.
(module
  (rec
    ;; CHECK:      (type $0 (func))

    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $X.vtable (sub (struct )))
    (type $X.vtable (sub (struct)))

    ;; CHECK:       (type $A.vtable (sub $X.vtable (struct )))
    (type $A.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $B.vtable (sub $X.vtable (struct )))
    (type $B.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $C.vtable (sub $A.vtable (struct )))
    (type $C.vtable (sub $A.vtable (struct)))

    ;; CHECK:       (type $D.vtable (sub $B.vtable (struct )))
    (type $D.vtable (sub $B.vtable (struct)))

    ;; CHECK:       (type $X (sub (struct (field (ref $X.vtable)))))
    (type $X (sub (struct (field (ref $X.vtable)))))

    ;; CHECK:       (type $A (sub $X (struct (field (ref $A.vtable)))))
    (type $A (sub $X (struct (field (ref $A.vtable)))))

    ;; CHECK:       (type $B (sub $X (struct (field (ref $B.vtable)))))
    (type $B (sub $X (struct (field (ref $B.vtable)))))

    ;; CHECK:       (type $C (sub $A (struct (field (ref $C.vtable)))))
    (type $C (sub $A (struct (field (ref $C.vtable)))))

    ;; CHECK:       (type $D (sub $B (struct (field (ref $D.vtable)))))
    (type $D (sub $B (struct (field (ref $D.vtable)))))
  )

  ;; CHECK:      (type $11 (func (result (ref $X))))

  ;; CHECK:      (type $12 (func (result (ref $A))))

  ;; CHECK:      (type $13 (func (result (ref $B))))

  ;; CHECK:      (import "a" "b" (func $import (type $11) (result (ref $X))))
  (import "a" "b" (func $import (result (ref $X))))

  ;; CHECK:      (import "a" "c" (func $import-A (type $12) (result (ref $A))))
  (import "a" "c" (func $import-A (result (ref $A))))

  ;; CHECK:      (import "a" "d" (func $import-B (type $13) (result (ref $B))))
  (import "a" "d" (func $import-B (result (ref $B))))

  ;; CHECK:      (func $create (type $0)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (struct.new_default $A.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (struct.new_default $B.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $C
  ;; CHECK-NEXT:    (struct.new_default $C.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $D
  ;; CHECK-NEXT:    (struct.new_default $D.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create
    (drop
      (struct.new $A
        (struct.new $A.vtable)
      )
    )
    (drop
      (struct.new $B
        (struct.new $B.vtable)
      )
    )
    (drop
      (struct.new $C
        (struct.new $C.vtable)
      )
    )
    (drop
      (struct.new $D
        (struct.new $D.vtable) ;; This changed.
      )
    )
  )

  ;; CHECK:      (func $test.X (type $0)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $C)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test.X
    ;; Loads from $X. We can optimize here.
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    (drop
      (ref.test (ref $C.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
  )

  ;; CHECK:      (func $test.A (type $0)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $A 0
  ;; CHECK-NEXT:      (call $import-A)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $C)
  ;; CHECK-NEXT:    (call $import-A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test.A
    ;; Loads from $A. The first must always succeed, while the second can be
    ;; optimized.
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $A 0
          (call $import-A)
        )
      )
    )
    (drop
      (ref.test (ref $C.vtable)
        (struct.get $A 0
          (call $import-A)
        )
      )
    )
  )

  ;; CHECK:      (func $test.B (type $0)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $B 0
  ;; CHECK-NEXT:      (call $import-B)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $D)
  ;; CHECK-NEXT:    (call $import-B)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test.B
    ;; Loads from $B. The first is trivial and the second can be optimized.
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $B 0
          (call $import-B)
        )
      )
    )
    (drop
      (ref.test (ref $D.vtable)
        (struct.get $B 0
          (call $import-B)
        )
      )
    )
  )
)

;; A nullable vtable, which makes things trickier.
(module
  ;; CHECK:      (type $vtable (sub (struct )))
  (type $vtable (sub (struct)))

  ;; CHECK:      (type $object (sub (struct (field (ref null $vtable)))))
  (type $object (sub (struct (field (ref null $vtable)))))

  ;; CHECK:      (type $2 (func (result (ref null $object))))

  ;; CHECK:      (type $3 (func))

  ;; CHECK:      (import "a" "b" (func $import (type $2) (result (ref null $object))))
  (import "a" "b" (func $import (result (ref null $object))))

  ;; CHECK:      (func $test (type $3)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new_default $object)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $object
  ;; CHECK-NEXT:    (struct.new_default $vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $vtable)
  ;; CHECK-NEXT:    (struct.get $object 0
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $object 0
  ;; CHECK-NEXT:      (call $import)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; The object is constructed with a null vtable sometimes.
    (drop
      (struct.new_default $object)
    )
    (drop
      (struct.new $object
        (struct.new $vtable)
      )
    )
    ;; A non-nullable test of $vtable. The heap type is correct, that much we
    ;; know, but it might be null, and that would make this check fail, so we
    ;; cannot infer here.
    (drop
      (ref.test (ref $vtable)
        (struct.get $object 0
          (call $import)
        )
      )
    )
    ;; A nullable test. This must succeed either way, in this case, and we
    ;; optimize it to 1.
    (drop
      (ref.test (ref null $vtable)
        (struct.get $object 0
          (call $import)
        )
      )
    )
  )
)
