;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt -all --gufa -S -o - | filecheck %s

;; Test optimizations for parallel type hierarchies (like objects and their
;; vtables

(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $X.vtable (sub (struct )))
    (type $X.vtable (sub (struct)))

    ;; CHECK:       (type $A.vtable (sub $X.vtable (struct )))
    (type $A.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $B.vtable (sub $X.vtable (struct )))
    (type $B.vtable (sub $X.vtable (struct)))

    ;; CHECK:       (type $X (sub (struct (field (ref $X.vtable)))))
    (type $X (sub (struct (field (ref $X.vtable)))))

    ;; CHECK:       (type $A (sub $X (struct (field (ref $A.vtable)))))
    (type $A (sub $X (struct (field (ref $A.vtable)))))

    ;; CHECK:       (type $B (sub $X (struct (field (ref $B.vtable)))))
    (type $B (sub $X (struct (field (ref $B.vtable)))))
  )

  ;; CHECK:      (type $6 (func))

  ;; CHECK:      (type $7 (func (result (ref null $X))))

  ;; CHECK:      (type $8 (func (result (ref $X))))

  ;; CHECK:      (import "a" "b" (func $import (type $7) (result (ref null $X))))
  (import "a" "b" (func $import (result (ref null $X))))

  ;; CHECK:      (import "a" "b" (func $import-nonnull (type $8) (result (ref $X))))
  (import "a" "b" (func $import-nonnull (result (ref $X))))

  ;; CHECK:      (global $X.vtable (ref $X.vtable) (struct.new_default $X.vtable))
  (global $X.vtable (ref $X.vtable) (struct.new $X.vtable))

  ;; CHECK:      (global $A.vtable (ref $A.vtable) (struct.new_default $A.vtable))
  (global $A.vtable (ref $A.vtable) (struct.new $A.vtable))

  ;; CHECK:      (global $B.vtable (ref $B.vtable) (struct.new_default $B.vtable))
  (global $B.vtable (ref $B.vtable) (struct.new $B.vtable))

  ;; CHECK:      (func $create (type $6)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $X
  ;; CHECK-NEXT:    (global.get $X.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (global.get $A.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (global.get $B.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create
    (drop
      (struct.new $X
        (global.get $X.vtable)
      )
    )
    (drop
      (struct.new $A
        (global.get $A.vtable)
      )
    )
    (drop
      (struct.new $B
        (global.get $B.vtable)
      )
    )
  )

  ;; CHECK:      (func $test (type $6)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B)
  ;; CHECK-NEXT:    (call $import-nonnull)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $X 0
  ;; CHECK-NEXT:      (call $import)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $A)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test (ref $B)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; The import contains an unknown value. Testing if it is an object with
    ;; $A's vtable can be replaced by testing if it is $A, directly.
    (drop
      (ref.test (ref $A.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    ;; Ditto, with $B.
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    ;; Ditto, with a non-nullable result from the import (which does not matter
    ;; to us).
    (drop
      (ref.test (ref $B.vtable)
        (struct.get $X 0
          (call $import-nonnull)
        )
      )
    )
    ;; For completion, tests of the other types, which are unoptimizable using
    ;; parallel type hierarchies (but the first is, separately, optimizable to
    ;; zero since the test is of an incompatible type).
    (drop
      (ref.test (ref $X)
        (struct.get $X 0
          (call $import)
        )
      )
    )
    (drop
      (ref.test (ref $A)
        (call $import)
      )
    )
    (drop
      (ref.test (ref $B)
        (call $import)
      )
    )
  )
)
