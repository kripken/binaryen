;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: wasm-opt %s -all --gdse -S -o - | filecheck %s

(module
 (type $A (struct (field (mut i32))))
 (type $B (struct (field (mut f64))))
 (type $C (struct (field (mut i32)) (field (mut i32))))

 (memory shared 10)

 (global $global$0 (mut i32) (i32.const 0))
 (global $global$1 (mut i32) (i32.const 0))

 (global $sp (mut i32) (i32.const 0))

 (func $do-nothing)

 ;; CHECK:      (func $calls-nothing-doer
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (i32.const 10)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (call $do-nothing)
 ;; CHECK-NEXT:  (global.set $global$0
 ;; CHECK-NEXT:   (i32.const 20)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $calls-nothing-doer
  (global.set $global$0
   (i32.const 10)
  )
  ;; This call has no relevant effects, and so we can see that the first store
  ;; here is killed by the last.
  (call $do-nothing)
  (global.set $global$0
   (i32.const 20)
  )
 )

 ;; CHECK:      (func $different-globals
 ;; CHECK-NEXT:  (global.set $global$0
 ;; CHECK-NEXT:   (i32.const 10)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (call $do-nothing)
 ;; CHECK-NEXT:  (global.set $global$1
 ;; CHECK-NEXT:   (i32.const 20)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $different-globals
  (global.set $global$0
   (i32.const 10)
  )
  ;; This call has no relevant effects, but the global below is different, and
  ;; so we cannot remove anything as dead.
  (call $do-nothing)
  (global.set $global$1
   (i32.const 20)
  )
 )

 ;; CHECK:      (func $sp-middle
 ;; CHECK-NEXT:  (local $old i32)
 ;; CHECK-NEXT:  (local.set $old
 ;; CHECK-NEXT:   (global.get $sp)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (drop
 ;; CHECK-NEXT:   (i32.add
 ;; CHECK-NEXT:    (global.get $sp)
 ;; CHECK-NEXT:    (i32.const 1)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (call $do-nothing)
 ;; CHECK-NEXT:  (global.set $sp
 ;; CHECK-NEXT:   (local.get $old)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $sp-middle
  (local $old i32)
  ;; Use the stack pointer in a realistic manner. This function will be at the
  ;; middle of a stack of calls:
  ;;
  ;;   $sp-bottom  =>  $sp-middle  =>  $do-nothing
  ;;
  (local.set $old
   (global.get $sp)
  )
  ;; As we will call $do-nothing, then trample, this store is dead.
  (global.set $sp
   (i32.add
    (global.get $sp)
    (i32.const 1)
   )
  )
  (call $do-nothing)
  ;; This store is dead, as all our callers will immediately trample it, but the
  ;; analysis does not handle that yet.
  (global.set $sp
   (local.get $old)
  )
 )

 ;; CHECK:      (func $sp-bottom
 ;; CHECK-NEXT:  (local $old i32)
 ;; CHECK-NEXT:  (local.set $old
 ;; CHECK-NEXT:   (global.get $sp)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (global.set $sp
 ;; CHECK-NEXT:   (i32.add
 ;; CHECK-NEXT:    (global.get $sp)
 ;; CHECK-NEXT:    (i32.const 1)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (call $sp-middle)
 ;; CHECK-NEXT:  (global.set $sp
 ;; CHECK-NEXT:   (local.get $old)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $sp-bottom
  (local $old i32)
  ;; As $sp-middle, but this is the bottom of a stack of calls.
  (local.set $old
   (global.get $sp)
  )
  ;; We will call $sp-middle, which reads the stack pointer, and so this is not
  ;; dead.
  (global.set $sp
   (i32.add
    (global.get $sp)
    (i32.const 1)
   )
  )
  (call $sp-middle)
  (global.set $sp
   (local.get $old)
  )
 )
)
