;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: wasm-opt %s --remove-unused-names --optimize-instructions -all -S -o - | filecheck %s
;; RUN: wasm-opt %s --remove-unused-names --rsse                  -all -S -o - | filecheck %s --check-prefix RSSE_

;; --remove-unused-names allows the optimizer to see that the blocks have no
;; breaks to them, and so they have no nonlinear control flow.

(module

  ;; CHECK:      (type $struct (struct (field (mut i32))))
  ;; RSSE_:      (type $struct (struct (field (mut i32))))
  (type $struct (struct (field (mut i32))))

  ;; CHECK:      (type $struct2 (struct (field (mut i32)) (field (mut i32))))
  ;; RSSE_:      (type $struct2 (struct (field (mut i32)) (field (mut i32))))
  (type $struct2 (struct (field (mut i32)) (field (mut i32))))

  ;; CHECK:      (type $struct3 (struct (field (mut i32)) (field (mut i32)) (field (mut i32))))
  ;; RSSE_:      (type $struct3 (struct (field (mut i32)) (field (mut i32)) (field (mut i32))))
  (type $struct3 (struct (field (mut i32)) (field (mut i32)) (field (mut i32))))

  ;; CHECK:      (type $struct4 (struct (field (mut i32)) (field (mut i32)) (field (mut i32)) (field (mut i32))))
  ;; RSSE_:      (type $struct4 (struct (field (mut i32)) (field (mut i32)) (field (mut i32)) (field (mut i32))))
  (type $struct4 (struct (field (mut i32)) (field (mut i32)) (field (mut i32)) (field (mut i32))))

  ;; CHECK:      (tag $tag)
  ;; RSSE_:      (tag $tag)
  (tag $tag)

  ;; CHECK:      (func $tee (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $tee (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct
  ;; RSSE_-NEXT:    (i32.const 20)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $tee
    (local $ref (ref null $struct))
    ;; The set is not needed as we can apply the 20 in the new.
    (struct.set $struct 0
      (local.tee $ref
        (struct.new $struct
          (i32.const 10)
        )
      )
      (i32.const 20)
    )
  )

  ;; CHECK:      (func $side-effects-in-old-value (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (block (result i32)
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (call $helper-i32
  ;; CHECK-NEXT:       (i32.const 0)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $side-effects-in-old-value (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct
  ;; RSSE_-NEXT:    (block (result i32)
  ;; RSSE_-NEXT:     (drop
  ;; RSSE_-NEXT:      (call $helper-i32
  ;; RSSE_-NEXT:       (i32.const 0)
  ;; RSSE_-NEXT:      )
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:     (i32.const 20)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $side-effects-in-old-value
    (local $ref (ref null $struct))
    (struct.set $struct 0
      (local.tee $ref
        (struct.new $struct
          ;; Side effects here force us to keep the old value around.
          (call $helper-i32 (i32.const 0))
        )
      )
      (i32.const 20)
    )
  )

  ;; CHECK:      (func $side-effects-in-new-value (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (call $helper-i32
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $side-effects-in-new-value (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct
  ;; RSSE_-NEXT:    (call $helper-i32
  ;; RSSE_-NEXT:     (i32.const 0)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $side-effects-in-new-value
    (local $ref (ref null $struct))
    (struct.set $struct 0
      (local.tee $ref
        (struct.new $struct
          (i32.const 10)
        )
      )
      ;; Side effects here are not a problem.
      (call $helper-i32 (i32.const 0))
    )
  )

  ;; CHECK:      (func $many-fields (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct2))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct2
  ;; CHECK-NEXT:    (i32.const 30)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct2
  ;; CHECK-NEXT:    (i32.const 40)
  ;; CHECK-NEXT:    (i32.const 60)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $many-fields (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct2))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct2
  ;; RSSE_-NEXT:    (i32.const 30)
  ;; RSSE_-NEXT:    (i32.const 20)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct2
  ;; RSSE_-NEXT:    (i32.const 40)
  ;; RSSE_-NEXT:    (i32.const 60)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $many-fields
    (local $ref (ref null $struct2))
    ;; Set to the first field.
    (struct.set $struct2 0
      (local.tee $ref
        (struct.new $struct2
          (i32.const 10)
          (i32.const 20)
        )
      )
      (i32.const 30)
    )
    ;; Set to the second.
    (struct.set $struct2 1
      (local.tee $ref
        (struct.new $struct2
          (i32.const 40)
          (i32.const 50)
        )
      )
      (i32.const 60)
    )
  )

  ;; CHECK:      (func $side-effect-conflict (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct2))
  ;; CHECK-NEXT:  (struct.set $struct2 0
  ;; CHECK-NEXT:   (local.tee $ref
  ;; CHECK-NEXT:    (struct.new $struct2
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (call $helper-i32
  ;; CHECK-NEXT:      (i32.const 0)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (call $helper-i32
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $side-effect-conflict (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct2))
  ;; RSSE_-NEXT:  (struct.set $struct2 0
  ;; RSSE_-NEXT:   (local.tee $ref
  ;; RSSE_-NEXT:    (struct.new $struct2
  ;; RSSE_-NEXT:     (i32.const 10)
  ;; RSSE_-NEXT:     (call $helper-i32
  ;; RSSE_-NEXT:      (i32.const 0)
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (call $helper-i32
  ;; RSSE_-NEXT:    (i32.const 1)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $side-effect-conflict
    (local $ref (ref null $struct2))
    (struct.set $struct2 0
      (local.tee $ref
        (struct.new $struct2
          (i32.const 10)
          ;; Side effects on the second field prevent us from moving the set's
          ;; value past it to replace the first field above it.
          (call $helper-i32 (i32.const 0))
        )
      )
      (call $helper-i32 (i32.const 1))
    )
  )

  ;; CHECK:      (func $side-effect-ok (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct2))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct2
  ;; CHECK-NEXT:    (block (result i32)
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (call $helper-i32
  ;; CHECK-NEXT:       (i32.const 0)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (call $helper-i32
  ;; CHECK-NEXT:      (i32.const 1)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $side-effect-ok (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct2))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct2
  ;; RSSE_-NEXT:    (block (result i32)
  ;; RSSE_-NEXT:     (drop
  ;; RSSE_-NEXT:      (call $helper-i32
  ;; RSSE_-NEXT:       (i32.const 0)
  ;; RSSE_-NEXT:      )
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:     (call $helper-i32
  ;; RSSE_-NEXT:      (i32.const 1)
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (i32.const 10)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $side-effect-ok
    (local $ref (ref null $struct2))
    (struct.set $struct2 0
      (local.tee $ref
        (struct.new $struct2
          ;; Side effects on the first field do not interfere.
          (call $helper-i32 (i32.const 0))
          (i32.const 10)
        )
      )
      (call $helper-i32 (i32.const 1))
    )
  )

  ;; CHECK:      (func $optimize-subsequent (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $optimize-subsequent (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct
  ;; RSSE_-NEXT:    (i32.const 20)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (nop)
  ;; RSSE_-NEXT: )
  (func $optimize-subsequent
    (local $ref (ref null $struct))
    (local.set $ref
      (struct.new $struct
        (i32.const 10)
      )
    )
    ;; A set that comes right after can be optimized too.
    (struct.set $struct 0
      (local.get $ref)
      (i32.const 20)
    )
  )

  ;; CHECK:      (func $optimize-subsequent-bad-local (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local $other (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.get $other)
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $optimize-subsequent-bad-local (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (local $other (ref null $struct))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct
  ;; RSSE_-NEXT:    (i32.const 10)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (struct.set $struct 0
  ;; RSSE_-NEXT:   (local.get $other)
  ;; RSSE_-NEXT:   (i32.const 20)
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $optimize-subsequent-bad-local
    (local $ref (ref null $struct))
    (local $other (ref null $struct))
    (local.set $ref
      (struct.new $struct
        (i32.const 10)
      )
    )
    ;; As above, but the local.get uses a different local, so we have nothing
    ;; to optimize.
    (struct.set $struct 0
      (local.get $other)
      (i32.const 20)
    )
  )

  ;; CHECK:      (func $optimize-chain (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 30)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $optimize-chain (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct
  ;; RSSE_-NEXT:    (i32.const 30)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (nop)
  ;; RSSE_-NEXT:  (nop)
  ;; RSSE_-NEXT: )
  (func $optimize-chain
    (local $ref (ref null $struct))
    (local.set $ref
      (struct.new $struct
        (i32.const 10)
      )
    )
    (struct.set $struct 0
      (local.get $ref)
      (i32.const 20)
    )
    ;; The value in the last item in the chain should apply.
    (struct.set $struct 0
      (local.get $ref)
      (i32.const 30)
    )
  )

  ;; CHECK:      (func $pattern-breaker (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $pattern-breaker (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct
  ;; RSSE_-NEXT:    (i32.const 10)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (nop)
  ;; RSSE_-NEXT:  (struct.set $struct 0
  ;; RSSE_-NEXT:   (local.get $ref)
  ;; RSSE_-NEXT:   (i32.const 20)
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $pattern-breaker
    (local $ref (ref null $struct))
    (local.set $ref
      (struct.new $struct
        (i32.const 10)
      )
    )
    ;; Anything that we don't recognize breaks the pattern.
    (nop)
    (struct.set $struct 0
      (local.get $ref)
      (i32.const 20)
    )
  )

  ;; CHECK:      (func $ref-local-write (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (local.set $ref
  ;; CHECK-NEXT:     (ref.null none)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $ref-local-write (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct
  ;; RSSE_-NEXT:    (i32.const 10)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (struct.set $struct 0
  ;; RSSE_-NEXT:   (local.get $ref)
  ;; RSSE_-NEXT:   (block (result i32)
  ;; RSSE_-NEXT:    (local.set $ref
  ;; RSSE_-NEXT:     (ref.null none)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (i32.const 20)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $ref-local-write
    (local $ref (ref null $struct))
    (local.set $ref
      (struct.new $struct
        (i32.const 10)
      )
    )
    (struct.set $struct 0
      (local.get $ref)
      (block (result i32)
        ;; A write to the ref local prevents us from optimizing.
        (local.set $ref
          (ref.null $struct)
        )
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $ref-local-write-tee (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.tee $ref
  ;; CHECK-NEXT:    (struct.new $struct
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (local.set $ref
  ;; CHECK-NEXT:     (ref.null none)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $ref-local-write-tee (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (struct.set $struct 0
  ;; RSSE_-NEXT:   (local.tee $ref
  ;; RSSE_-NEXT:    (struct.new $struct
  ;; RSSE_-NEXT:     (i32.const 10)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (block (result i32)
  ;; RSSE_-NEXT:    (local.set $ref
  ;; RSSE_-NEXT:     (ref.null none)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (i32.const 20)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $ref-local-write-tee
    (local $ref (ref null $struct))
    (struct.set $struct 0
      (local.tee $ref
        (struct.new $struct
          (i32.const 10)
        )
      )
      (block (result i32)
        ;; As above, but now in a tee.
        (local.set $ref
          (ref.null $struct)
        )
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $other-local-write (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local $other (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (block (result i32)
  ;; CHECK-NEXT:     (local.set $other
  ;; CHECK-NEXT:      (ref.null none)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $other-local-write (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (local $other (ref null $struct))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct
  ;; RSSE_-NEXT:    (block (result i32)
  ;; RSSE_-NEXT:     (local.set $other
  ;; RSSE_-NEXT:      (ref.null none)
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:     (i32.const 20)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (nop)
  ;; RSSE_-NEXT: )
  (func $other-local-write
    (local $ref (ref null $struct))
    (local $other (ref null $struct))
    (local.set $ref
      (struct.new $struct
        (i32.const 10)
      )
    )
    (struct.set $struct 0
      (local.get $ref)
      (block (result i32)
        ;; A write to another local is fine.
        (local.set $other
          (ref.null $struct)
        )
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $ref-local-read (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $ref-local-read (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct
  ;; RSSE_-NEXT:    (i32.const 10)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (struct.set $struct 0
  ;; RSSE_-NEXT:   (local.get $ref)
  ;; RSSE_-NEXT:   (block (result i32)
  ;; RSSE_-NEXT:    (drop
  ;; RSSE_-NEXT:     (local.get $ref)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (i32.const 20)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $ref-local-read
    (local $ref (ref null $struct))
    (local.set $ref
      (struct.new $struct
        (i32.const 10)
      )
    )
    (struct.set $struct 0
      (local.get $ref)
      (block (result i32)
        ;; A read of the ref local prevents us from optimizing.
        (drop
          (local.get $ref)
        )
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $ref-local-read-tee (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.tee $ref
  ;; CHECK-NEXT:    (struct.new $struct
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $ref-local-read-tee (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (struct.set $struct 0
  ;; RSSE_-NEXT:   (local.tee $ref
  ;; RSSE_-NEXT:    (struct.new $struct
  ;; RSSE_-NEXT:     (i32.const 10)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (block (result i32)
  ;; RSSE_-NEXT:    (drop
  ;; RSSE_-NEXT:     (local.get $ref)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (i32.const 20)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $ref-local-read-tee
    (local $ref (ref null $struct))
    (struct.set $struct 0
      (local.tee $ref
        (struct.new $struct
          (i32.const 10)
        )
      )
      (block (result i32)
        ;; As above, but now in a tee.
        (drop
          (local.get $ref)
        )
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $ref-other-read (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local $other (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (block (result i32)
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (local.get $other)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $ref-other-read (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (local $other (ref null $struct))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct
  ;; RSSE_-NEXT:    (block (result i32)
  ;; RSSE_-NEXT:     (drop
  ;; RSSE_-NEXT:      (local.get $other)
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:     (i32.const 20)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (nop)
  ;; RSSE_-NEXT: )
  (func $ref-other-read
    (local $ref (ref null $struct))
    (local $other (ref null $struct))
    (local.set $ref
      (struct.new $struct
        (i32.const 10)
      )
    )
    (struct.set $struct 0
      (local.get $ref)
      (block (result i32)
        ;; A read of another local is fine.
        (drop
          (local.get $other)
        )
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $tee-and-subsequent (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct3))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct3
  ;; CHECK-NEXT:    (i32.const 40)
  ;; CHECK-NEXT:    (i32.const 50)
  ;; CHECK-NEXT:    (i32.const 60)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $tee-and-subsequent (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct3))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct3
  ;; RSSE_-NEXT:    (i32.const 40)
  ;; RSSE_-NEXT:    (i32.const 50)
  ;; RSSE_-NEXT:    (i32.const 60)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (nop)
  ;; RSSE_-NEXT:  (nop)
  ;; RSSE_-NEXT: )
  (func $tee-and-subsequent
    (local $ref (ref null $struct3))
    ;; Test the common pattern of several subsequent sets, one of which is
    ;; using a tee.
    (struct.set $struct3 0
      (local.tee $ref
        (struct.new $struct3
          (i32.const 10)
          (i32.const 20)
          (i32.const 30)
        )
      )
      (i32.const 40)
    )
    (struct.set $struct3 1
      (local.get $ref)
      (i32.const 50)
    )
    (struct.set $struct3 2
      (local.get $ref)
      (i32.const 60)
    )
  )

  ;; CHECK:      (func $side-effect-subsequent-ok (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct2))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct2
  ;; CHECK-NEXT:    (call $helper-i32
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (call $helper-i32
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $side-effect-subsequent-ok (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct2))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct2
  ;; RSSE_-NEXT:    (call $helper-i32
  ;; RSSE_-NEXT:     (i32.const 0)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (call $helper-i32
  ;; RSSE_-NEXT:     (i32.const 1)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (nop)
  ;; RSSE_-NEXT: )
  (func $side-effect-subsequent-ok
    (local $ref (ref null $struct2))
    (local.set $ref
      (struct.new $struct2
        ;; The first field has side effects, but the second does not.
        (call $helper-i32 (i32.const 0))
        (i32.const 10)
      )
    )
    ;; Replace the second field with something with side effects.
    (struct.set $struct2 1
      (local.get $ref)
      (call $helper-i32 (i32.const 1))
    )
  )

  ;; CHECK:      (func $default (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.tee $ref
  ;; CHECK-NEXT:    (struct.new_default $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $default (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (struct.set $struct 0
  ;; RSSE_-NEXT:   (local.tee $ref
  ;; RSSE_-NEXT:    (struct.new_default $struct)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (i32.const 20)
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $default
    (local $ref (ref null $struct))
    (struct.set $struct 0
      (local.tee $ref
        ;; Ignore a new_default for now. If the fields are defaultable then we
        ;; could add them, in principle, but that might increase code size.
        (struct.new_default $struct)
      )
      (i32.const 20)
    )
  )

  ;; CHECK:      (func $many-news (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct3))
  ;; CHECK-NEXT:  (local $ref2 (ref null $struct3))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct3
  ;; CHECK-NEXT:    (i32.const 40)
  ;; CHECK-NEXT:    (i32.const 50)
  ;; CHECK-NEXT:    (i32.const 30)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (struct.set $struct3 2
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (i32.const 60)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct3
  ;; CHECK-NEXT:    (i32.const 400)
  ;; CHECK-NEXT:    (i32.const 200)
  ;; CHECK-NEXT:    (i32.const 500)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (block
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $struct3
  ;; CHECK-NEXT:     (i32.const 40)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 30)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref2
  ;; CHECK-NEXT:    (struct.new $struct3
  ;; CHECK-NEXT:     (i32.const 400)
  ;; CHECK-NEXT:     (i32.const 600)
  ;; CHECK-NEXT:     (i32.const 500)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (nop)
  ;; CHECK-NEXT:   (nop)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $many-news (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct3))
  ;; RSSE_-NEXT:  (local $ref2 (ref null $struct3))
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct3
  ;; RSSE_-NEXT:    (i32.const 40)
  ;; RSSE_-NEXT:    (i32.const 50)
  ;; RSSE_-NEXT:    (i32.const 30)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (nop)
  ;; RSSE_-NEXT:  (nop)
  ;; RSSE_-NEXT:  (struct.set $struct3 2
  ;; RSSE_-NEXT:   (local.get $ref)
  ;; RSSE_-NEXT:   (i32.const 60)
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (nop)
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct3
  ;; RSSE_-NEXT:    (i32.const 400)
  ;; RSSE_-NEXT:    (i32.const 200)
  ;; RSSE_-NEXT:    (i32.const 500)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (nop)
  ;; RSSE_-NEXT:  (block
  ;; RSSE_-NEXT:   (local.set $ref
  ;; RSSE_-NEXT:    (struct.new $struct3
  ;; RSSE_-NEXT:     (i32.const 40)
  ;; RSSE_-NEXT:     (i32.const 20)
  ;; RSSE_-NEXT:     (i32.const 30)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (local.set $ref2
  ;; RSSE_-NEXT:    (struct.new $struct3
  ;; RSSE_-NEXT:     (i32.const 400)
  ;; RSSE_-NEXT:     (i32.const 600)
  ;; RSSE_-NEXT:     (i32.const 500)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (nop)
  ;; RSSE_-NEXT:   (nop)
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $many-news
    (local $ref (ref null $struct3))
    (local $ref2 (ref null $struct3))
    ;; Test that we optimize for multiple struct.news in the same function.
    (struct.set $struct3 0
      (local.tee $ref
        (struct.new $struct3
          (i32.const 10)
          (i32.const 20)
          (i32.const 30)
        )
      )
      (i32.const 40)
    )
    (struct.set $struct3 1
      (local.get $ref)
      (i32.const 50)
    )
    (nop)
    (struct.set $struct3 2
      (local.get $ref)
      (i32.const 60)
    )
    (nop)
    (struct.set $struct3 0
      (local.tee $ref
        (struct.new $struct3
          (i32.const 100)
          (i32.const 200)
          (i32.const 300)
        )
      )
      (i32.const 400)
    )
    (struct.set $struct3 2
      (local.get $ref)
      (i32.const 500)
    )
    ;; Test inside an inner block.
    (block $inner
      (struct.set $struct3 0
        (local.tee $ref
          (struct.new $struct3
            (i32.const 10)
            (i32.const 20)
            (i32.const 30)
          )
        )
        (i32.const 40)
      )
      ;; Use a different ref local here.
      (struct.set $struct3 0
        (local.tee $ref2
          (struct.new $struct3
            (i32.const 100)
            (i32.const 200)
            (i32.const 300)
          )
        )
        (i32.const 400)
      )
      (struct.set $struct3 2
        (local.get $ref2)
        (i32.const 500)
      )
      (struct.set $struct3 1
        (local.get $ref2)
        (i32.const 600)
      )
    )
  )

  ;; CHECK:      (func $unreachable (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.tee $ref
  ;; CHECK-NEXT:   (block ;; (replaces something unreachable we can't emit)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $struct
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.set $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $unreachable (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (local.tee $ref
  ;; RSSE_-NEXT:   (block ;; (replaces something unreachable we can't emit)
  ;; RSSE_-NEXT:    (drop
  ;; RSSE_-NEXT:     (unreachable)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (unreachable)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (struct.set $struct 0
  ;; RSSE_-NEXT:   (local.get $ref)
  ;; RSSE_-NEXT:   (i32.const 10)
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (nop)
  ;; RSSE_-NEXT:  (local.set $ref
  ;; RSSE_-NEXT:   (struct.new $struct
  ;; RSSE_-NEXT:    (i32.const 20)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (struct.set $struct 0
  ;; RSSE_-NEXT:   (local.get $ref)
  ;; RSSE_-NEXT:   (unreachable)
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $unreachable
    (local $ref (ref null $struct))
    ;; Do not optimize unreachable code, either in the new (first pair) or the
    ;; set (second pair)
    (local.set $ref
      (struct.new $struct
        (unreachable)
      )
    )
    (struct.set $struct 0
      (local.get $ref)
      (i32.const 10)
    )
    (nop)
    (local.set $ref
      (struct.new $struct
        (i32.const 20)
      )
    )
    (struct.set $struct 0
      (local.get $ref)
      (unreachable)
    )
  )

  ;; CHECK:      (func $helper-i32 (type $6) (param $x i32) (result i32)
  ;; CHECK-NEXT:  (i32.const 42)
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $helper-i32 (type $6) (param $x i32) (result i32)
  ;; RSSE_-NEXT:  (i32.const 42)
  ;; RSSE_-NEXT: )
  (func $helper-i32 (param $x i32) (result i32)
    (i32.const 42)
  )

  ;; CHECK:      (func $cfg-branch (type $4) (result i32)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (block $out
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $struct
  ;; CHECK-NEXT:     (if (result i32)
  ;; CHECK-NEXT:      (i32.const 2)
  ;; CHECK-NEXT:      (then
  ;; CHECK-NEXT:       (br $out)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (else
  ;; CHECK-NEXT:       (i32.const 3)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.get $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $cfg-branch (type $4) (result i32)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (block $out
  ;; RSSE_-NEXT:   (struct.set $struct 0
  ;; RSSE_-NEXT:    (local.tee $ref
  ;; RSSE_-NEXT:     (struct.new $struct
  ;; RSSE_-NEXT:      (i32.const 1)
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (if (result i32)
  ;; RSSE_-NEXT:     (i32.const 2)
  ;; RSSE_-NEXT:     (then
  ;; RSSE_-NEXT:      (br $out)
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:     (else
  ;; RSSE_-NEXT:      (i32.const 3)
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (struct.get $struct 0
  ;; RSSE_-NEXT:   (local.get $ref)
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $cfg-branch (result i32)
    (local $ref (ref null $struct))

    ;; This testcase requires CFG analysis: there is a branch that skips the
    ;; struct.set, and the reference can be used there. We should not optimize
    ;; away the struct.set here.

    (block $out
      (struct.set $struct 0
        (local.tee $ref
          (struct.new $struct
            (i32.const 1)
          )
        )
        ;; Use an if here so the pass doesn't trivially see unreachable code
        ;; after us.
        (if (result i32)
          (i32.const 2)
          (then
            (br $out)
          )
          (else
            (i32.const 3)
          )
        )
      )
    )
    (struct.get $struct 0
      (local.get $ref)
    )
  )

  ;; CHECK:      (func $cfg-throw (type $4) (result i32)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (local.set $ref
  ;; CHECK-NEXT:     (struct.new $struct
  ;; CHECK-NEXT:      (call $cfg-throw)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $tag
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.get $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $cfg-throw (type $4) (result i32)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (try
  ;; RSSE_-NEXT:   (do
  ;; RSSE_-NEXT:    (struct.set $struct 0
  ;; RSSE_-NEXT:     (local.tee $ref
  ;; RSSE_-NEXT:      (struct.new $struct
  ;; RSSE_-NEXT:       (i32.const 1)
  ;; RSSE_-NEXT:      )
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:     (call $cfg-throw)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (catch $tag
  ;; RSSE_-NEXT:    (nop)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (struct.get $struct 0
  ;; RSSE_-NEXT:   (local.get $ref)
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $cfg-throw (result i32)
    (local $ref (ref null $struct))
    ;; As above but with a call (which might throw). We cannot remove the
    ;; struct.set here either.
    (try
      (do
        (struct.set $struct 0
          (local.tee $ref
            (struct.new $struct
              (i32.const 1)
            )
          )
          (call $cfg-throw)
        )
      )
      (catch $tag)
    )
    (struct.get $struct 0
      (local.get $ref)
    )
  )

  ;; CHECK:      (func $cfg-throw-notee (type $4) (result i32)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (local.set $ref
  ;; CHECK-NEXT:     (struct.new $struct
  ;; CHECK-NEXT:      (call $cfg-throw)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $tag
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.get $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $cfg-throw-notee (type $4) (result i32)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (try
  ;; RSSE_-NEXT:   (do
  ;; RSSE_-NEXT:    (local.set $ref
  ;; RSSE_-NEXT:     (struct.new $struct
  ;; RSSE_-NEXT:      (i32.const 1)
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (struct.set $struct 0
  ;; RSSE_-NEXT:     (local.get $ref)
  ;; RSSE_-NEXT:     (call $cfg-throw)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (catch $tag
  ;; RSSE_-NEXT:    (nop)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (struct.get $struct 0
  ;; RSSE_-NEXT:   (local.get $ref)
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $cfg-throw-notee (result i32)
    (local $ref (ref null $struct))
    ;; As above but we have a local.set/get rather than a tee. We cannot
    ;; optimize here.
    (try
      (do
        (local.set $ref
          (struct.new $struct
            (i32.const 1)
          )
        )
        (struct.set $struct 0
          (local.get $ref)
          (call $cfg-throw)
        )
      )
      (catch $tag)
    )
    (struct.get $struct 0
      (local.get $ref)
    )
  )

  ;; CHECK:      (func $cfg-throw-if (type $4) (result i32)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (local.set $ref
  ;; CHECK-NEXT:     (struct.new $struct
  ;; CHECK-NEXT:      (if (result i32)
  ;; CHECK-NEXT:       (i32.const 2)
  ;; CHECK-NEXT:       (then
  ;; CHECK-NEXT:        (call $cfg-throw-if)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:       (else
  ;; CHECK-NEXT:        (i32.const 3)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $tag
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.get $struct 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $cfg-throw-if (type $4) (result i32)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (try
  ;; RSSE_-NEXT:   (do
  ;; RSSE_-NEXT:    (struct.set $struct 0
  ;; RSSE_-NEXT:     (local.tee $ref
  ;; RSSE_-NEXT:      (struct.new $struct
  ;; RSSE_-NEXT:       (i32.const 1)
  ;; RSSE_-NEXT:      )
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:     (if (result i32)
  ;; RSSE_-NEXT:      (i32.const 2)
  ;; RSSE_-NEXT:      (then
  ;; RSSE_-NEXT:       (call $cfg-throw-if)
  ;; RSSE_-NEXT:      )
  ;; RSSE_-NEXT:      (else
  ;; RSSE_-NEXT:       (i32.const 3)
  ;; RSSE_-NEXT:      )
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (catch $tag
  ;; RSSE_-NEXT:    (nop)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (struct.get $struct 0
  ;; RSSE_-NEXT:   (local.get $ref)
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $cfg-throw-if (result i32)
    (local $ref (ref null $struct))
    ;; As above but the call is nested in more control flow, an if. We cannot
    ;; optimize here.
    (try
      (do
        (struct.set $struct 0
          (local.tee $ref
            (struct.new $struct
              (i32.const 1)
            )
          )
          (if (result i32)
            (i32.const 2)
            (then
              (call $cfg-throw-if)
            )
            (else
              (i32.const 3)
            )
          )
        )
      )
      (catch $tag)
    )
    (struct.get $struct 0
      (local.get $ref)
    )
  )

  ;; CHECK:      (func $cfg-throw-if-end (type $4) (result i32)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (local.set $ref
  ;; CHECK-NEXT:     (struct.new $struct
  ;; CHECK-NEXT:      (call $cfg-throw-if)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $tag
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.get $struct 0
  ;; CHECK-NEXT:   (if (result (ref null $struct))
  ;; CHECK-NEXT:    (i32.const 2)
  ;; CHECK-NEXT:    (then
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (else
  ;; CHECK-NEXT:     (return
  ;; CHECK-NEXT:      (i32.const 3)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $cfg-throw-if-end (type $4) (result i32)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (try
  ;; RSSE_-NEXT:   (do
  ;; RSSE_-NEXT:    (struct.set $struct 0
  ;; RSSE_-NEXT:     (local.tee $ref
  ;; RSSE_-NEXT:      (struct.new $struct
  ;; RSSE_-NEXT:       (i32.const 1)
  ;; RSSE_-NEXT:      )
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:     (call $cfg-throw-if)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (catch $tag
  ;; RSSE_-NEXT:    (nop)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (struct.get $struct 0
  ;; RSSE_-NEXT:   (if (result (ref null $struct))
  ;; RSSE_-NEXT:    (i32.const 2)
  ;; RSSE_-NEXT:    (then
  ;; RSSE_-NEXT:     (local.get $ref)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (else
  ;; RSSE_-NEXT:     (return
  ;; RSSE_-NEXT:      (i32.const 3)
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $cfg-throw-if-end (result i32)
    (local $ref (ref null $struct))
    ;; As above but the dangerous local.get later is nested in more control
    ;; flow, an if. We cannot optimize here.
    (try
      (do
        (struct.set $struct 0
          (local.tee $ref
            (struct.new $struct
              (i32.const 1)
            )
          )
          (call $cfg-throw-if)
        )
      )
      (catch $tag)
    )
    (struct.get $struct 0
      (if (result (ref null $struct))
        (i32.const 2)
        (then
          (local.get $ref)
        )
        (else
          (return
            (i32.const 3)
          )
        )
      )
    )
  )

  ;; CHECK:      (func $cfg-throw-ok (type $4) (result i32)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (local.set $ref
  ;; CHECK-NEXT:     (struct.new $struct
  ;; CHECK-NEXT:      (call $cfg-throw-ok)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $tag
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (i32.const 2)
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $cfg-throw-ok (type $4) (result i32)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (try
  ;; RSSE_-NEXT:   (do
  ;; RSSE_-NEXT:    (local.set $ref
  ;; RSSE_-NEXT:     (struct.new $struct
  ;; RSSE_-NEXT:      (call $cfg-throw-ok)
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (catch $tag
  ;; RSSE_-NEXT:    (nop)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (i32.const 2)
  ;; RSSE_-NEXT: )
  (func $cfg-throw-ok (result i32)
    (local $ref (ref null $struct))
    ;; As above but the ref is not used in the throwing path, so we can
    ;; optimize.
    (try
      (do
        (struct.set $struct 0
          (local.tee $ref
            (struct.new $struct
              (i32.const 1)
            )
          )
          (call $cfg-throw-ok)
        )
      )
      (catch $tag)
    )
    ;; There used to be a local.get of $ref here.
    (i32.const 2)
  )

  ;; CHECK:      (func $cfg-throw-ok-notee (type $4) (result i32)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (local.set $ref
  ;; CHECK-NEXT:     (struct.new $struct
  ;; CHECK-NEXT:      (call $cfg-throw-ok)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $tag
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (i32.const 2)
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $cfg-throw-ok-notee (type $4) (result i32)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (try
  ;; RSSE_-NEXT:   (do
  ;; RSSE_-NEXT:    (local.set $ref
  ;; RSSE_-NEXT:     (struct.new $struct
  ;; RSSE_-NEXT:      (call $cfg-throw-ok)
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (nop)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (catch $tag
  ;; RSSE_-NEXT:    (nop)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (i32.const 2)
  ;; RSSE_-NEXT: )
  (func $cfg-throw-ok-notee (result i32)
    (local $ref (ref null $struct))
    ;; As above but with a local.set/get rather than a tee. We can optimize.
    (try
      (do
        (local.set $ref
          (struct.new $struct
            (i32.const 1)
          )
        )
        (struct.set $struct 0
          (local.get $ref)
          (call $cfg-throw-ok)
        )
      )
      (catch $tag)
    )
    (i32.const 2)
  )

  ;; CHECK:      (func $cfg-throw-ok-if (type $4) (result i32)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (local.set $ref
  ;; CHECK-NEXT:     (struct.new $struct
  ;; CHECK-NEXT:      (if (result i32)
  ;; CHECK-NEXT:       (i32.const 2)
  ;; CHECK-NEXT:       (then
  ;; CHECK-NEXT:        (call $cfg-throw-ok-if)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:       (else
  ;; CHECK-NEXT:        (i32.const 3)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $tag
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (i32.const 2)
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $cfg-throw-ok-if (type $4) (result i32)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (try
  ;; RSSE_-NEXT:   (do
  ;; RSSE_-NEXT:    (local.set $ref
  ;; RSSE_-NEXT:     (struct.new $struct
  ;; RSSE_-NEXT:      (if (result i32)
  ;; RSSE_-NEXT:       (i32.const 2)
  ;; RSSE_-NEXT:       (then
  ;; RSSE_-NEXT:        (call $cfg-throw-ok-if)
  ;; RSSE_-NEXT:       )
  ;; RSSE_-NEXT:       (else
  ;; RSSE_-NEXT:        (i32.const 3)
  ;; RSSE_-NEXT:       )
  ;; RSSE_-NEXT:      )
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (catch $tag
  ;; RSSE_-NEXT:    (nop)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (i32.const 2)
  ;; RSSE_-NEXT: )
  (func $cfg-throw-ok-if (result i32)
    (local $ref (ref null $struct))
    ;; As above but the call is nested in more control flow, an if. We can
    ;; optimize here despite the extra control flow.
    (try
      (do
        (struct.set $struct 0
          (local.tee $ref
            (struct.new $struct
              (i32.const 1)
            )
          )
          (if (result i32)
            (i32.const 2)
            (then
              (call $cfg-throw-ok-if)
            )
            (else
              (i32.const 3)
            )
          )
        )
      )
      (catch $tag)
    )
    (i32.const 2)
  )

  ;; CHECK:      (func $cfg-throw-ok-if-end (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (local.set $ref
  ;; CHECK-NEXT:     (struct.new $struct
  ;; CHECK-NEXT:      (call $cfg-throw-if)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $tag
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 2)
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (local.set $ref
  ;; CHECK-NEXT:     (ref.null none)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (else
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (i32.const 3)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $cfg-throw-ok-if-end (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (try
  ;; RSSE_-NEXT:   (do
  ;; RSSE_-NEXT:    (local.set $ref
  ;; RSSE_-NEXT:     (struct.new $struct
  ;; RSSE_-NEXT:      (call $cfg-throw-if)
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (catch $tag
  ;; RSSE_-NEXT:    (nop)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (if
  ;; RSSE_-NEXT:   (i32.const 2)
  ;; RSSE_-NEXT:   (then
  ;; RSSE_-NEXT:    (local.set $ref
  ;; RSSE_-NEXT:     (ref.null none)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (drop
  ;; RSSE_-NEXT:     (local.get $ref)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (else
  ;; RSSE_-NEXT:    (drop
  ;; RSSE_-NEXT:     (i32.const 3)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $cfg-throw-ok-if-end
    (local $ref (ref null $struct))
    ;; As above but there is a bunch of extra control flow at the end, and also
    ;; a suspicious local.get that is luckily behind a local.set. We can
    ;; optimize here despite all that.
    (try
      (do
        (struct.set $struct 0
          (local.tee $ref
            (struct.new $struct
              (i32.const 1)
            )
          )
          (call $cfg-throw-if)
        )
      )
      (catch $tag)
    )
    (if
      (i32.const 2)
      (then
        (local.set $ref
          (ref.null $struct)
        )
        (drop
          (local.get $ref)
        )
      )
      (else
        (drop
          (i32.const 3)
        )
      )
    )
  )

  ;; CHECK:      (func $cfg-throw-ok-if-end-flip (type $1)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (local.set $ref
  ;; CHECK-NEXT:     (struct.new $struct
  ;; CHECK-NEXT:      (call $cfg-throw-if)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $tag
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (i32.const 2)
  ;; CHECK-NEXT:   (then
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (local.set $ref
  ;; CHECK-NEXT:     (ref.null none)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (else
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (i32.const 3)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $cfg-throw-ok-if-end-flip (type $1)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct))
  ;; RSSE_-NEXT:  (try
  ;; RSSE_-NEXT:   (do
  ;; RSSE_-NEXT:    (struct.set $struct 0
  ;; RSSE_-NEXT:     (local.tee $ref
  ;; RSSE_-NEXT:      (struct.new $struct
  ;; RSSE_-NEXT:       (i32.const 1)
  ;; RSSE_-NEXT:      )
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:     (call $cfg-throw-if)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (catch $tag
  ;; RSSE_-NEXT:    (nop)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (if
  ;; RSSE_-NEXT:   (i32.const 2)
  ;; RSSE_-NEXT:   (then
  ;; RSSE_-NEXT:    (drop
  ;; RSSE_-NEXT:     (local.get $ref)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (local.set $ref
  ;; RSSE_-NEXT:     (ref.null none)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (else
  ;; RSSE_-NEXT:    (drop
  ;; RSSE_-NEXT:     (i32.const 3)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $cfg-throw-ok-if-end-flip
    (local $ref (ref null $struct))
    ;; As $cfg-throw-ok-if-end but with the local.set/get flipped near the end
    ;; of the function. The flipped order means the local.get is live, and we
    ;; cannot optimize.
    (try
      (do
        (struct.set $struct 0
          (local.tee $ref
            (struct.new $struct
              (i32.const 1)
            )
          )
          (call $cfg-throw-if)
        )
      )
      (catch $tag)
    )
    (if
      (i32.const 2)
      (then
        (drop
          (local.get $ref)
        )
        (local.set $ref
          (ref.null $struct)
        )
      )
      (else
        (drop
          (i32.const 3)
        )
      )
    )
  )

  ;; CHECK:      (func $cfg-throw-ok-series (type $4) (result i32)
  ;; CHECK-NEXT:  (local $ref (ref null $struct4))
  ;; CHECK-NEXT:  (try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (local.set $ref
  ;; CHECK-NEXT:     (struct.new $struct4
  ;; CHECK-NEXT:      (i32.const 10)
  ;; CHECK-NEXT:      (i32.const 20)
  ;; CHECK-NEXT:      (call $cfg-throw-ok-series)
  ;; CHECK-NEXT:      (i32.const 30)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $tag
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (struct.get $struct4 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  ;; RSSE_:      (func $cfg-throw-ok-series (type $4) (result i32)
  ;; RSSE_-NEXT:  (local $ref (ref null $struct4))
  ;; RSSE_-NEXT:  (try
  ;; RSSE_-NEXT:   (do
  ;; RSSE_-NEXT:    (local.set $ref
  ;; RSSE_-NEXT:     (struct.new $struct4
  ;; RSSE_-NEXT:      (i32.const 0)
  ;; RSSE_-NEXT:      (i32.const 1)
  ;; RSSE_-NEXT:      (i32.const 2)
  ;; RSSE_-NEXT:      (i32.const 3)
  ;; RSSE_-NEXT:     )
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (struct.set $struct4 0
  ;; RSSE_-NEXT:     (local.get $ref)
  ;; RSSE_-NEXT:     (i32.const 10)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (struct.set $struct4 1
  ;; RSSE_-NEXT:     (local.get $ref)
  ;; RSSE_-NEXT:     (i32.const 20)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (struct.set $struct4 2
  ;; RSSE_-NEXT:     (local.get $ref)
  ;; RSSE_-NEXT:     (call $cfg-throw-ok-series)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:    (struct.set $struct4 3
  ;; RSSE_-NEXT:     (local.get $ref)
  ;; RSSE_-NEXT:     (i32.const 30)
  ;; RSSE_-NEXT:    )
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:   (catch $tag
  ;; RSSE_-NEXT:    (nop)
  ;; RSSE_-NEXT:   )
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT:  (struct.get $struct4 0
  ;; RSSE_-NEXT:   (local.get $ref)
  ;; RSSE_-NEXT:  )
  ;; RSSE_-NEXT: )
  (func $cfg-throw-ok-series (result i32)
    (local $ref (ref null $struct4))
    ;; A series of struct.sets. We can optimize the first two and are then
    ;; blocked by the third, which prevents optimizing either itself or the
    ;; fourth. XXX
    (try
      (do
        (local.set $ref
          (struct.new $struct4
            (i32.const 0)
            (i32.const 1)
            (i32.const 2)
            (i32.const 3)
          )
        )
        (struct.set $struct4 0
          (local.get $ref)
          (i32.const 10)
        )
        (struct.set $struct4 1
          (local.get $ref)
          (i32.const 20)
        )
        (struct.set $struct4 2
          (local.get $ref)
          (call $cfg-throw-ok-series)
        )
        (struct.set $struct4 3
          (local.get $ref)
          (i32.const 30)
        )
      )
      (catch $tag)
    )
    (struct.get $struct4 0
      (local.get $ref)
    )
  )

  (func $cfg-throw-ok-series-tee (result i32)
    (local $ref (ref null $struct4))
    ;; As above but we begin with a tee. Again, we can optimize the first two
    ;; struct.sets away.
    (try
      (do
        (struct.set $struct4 0
          (local.tee $ref
            (struct.new $struct4
              (i32.const 0)
              (i32.const 1)
              (i32.const 2)
              (i32.const 3)
            )
          )
          (i32.const 10)
        )
        (struct.set $struct4 1
          (local.get $ref)
          (i32.const 20)
        )
        (struct.set $struct4 2
          (local.get $ref)
          (call $cfg-throw-ok-series-tee)
        )
        (struct.set $struct4 3
          (local.get $ref)
          (i32.const 30)
        )
      )
      (catch $tag)
    )
    (struct.get $struct4 0
      (local.get $ref)
    )
  )
)
